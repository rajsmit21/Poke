<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self';
        connect-src 'self' https://pokeapi.co;
        img-src 'self' https://raw.githubusercontent.com data:;
        style-src 'self' 'unsafe-inline';
        script-src 'self' 'unsafe-inline';
    ">
    <title>Pokémon Info</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            transition: background-color 0.5s;
        }
        .container {
            max-width: 800px;
            background: #fff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
            text-align: center;
            width: 100%;
        }
        h1 {
            color: #333;
            margin-bottom: 10px;
        }
        .search-container {
            position: relative;
            margin-bottom: 20px;
        }
        #search-bar {
            width: 100%;
            max-width: 400px;
            padding: 10px;
            font-size: 16px;
            border: 2px solid #333;
            border-radius: 5px;
            outline: none;
        }
        #suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            max-width: 400px;
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 5px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 10;
            display: none;
        }
        .suggestion-item {
            padding: 10px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }
        .suggestion-item:hover {
            background-color: #f0f0f0;
        }
        .pokemon-info {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
        }
        .pokemon-image {
            flex: 1;
            min-width: 200px;
        }
        canvas {
            border: 2px solid #333;
            border-radius: 10px;
            background: #f0f0f0;
        }
        .details {
            flex: 2;
            min-width: 300px;
            text-align: left;
        }
        .details p, .details ul {
            margin: 10px 0;
        }
        .moves-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 5px;
        }
        .moves-list li {
            list-style: none;
            padding: 5px 0;
        }
        .error {
            color: red;
            font-weight: bold;
        }
        /* Type-based background colors */
        .type-normal { background-color: #A8A878; }
        .type-fire { background-color: #F08030; }
        .type-water { background-color: #6890F0; }
        .type-grass { background-color: #78C850; }
        .type-electric { background-color: #F8D030; }
        .type-ice { background-color: #98D8D8; }
        .type-fighting { background-color: #C03028; }
        .type-poison { background-color: #A040A0; }
        .type-ground { background-color: #E0C068; }
        .type-flying { background-color: #A890F0; }
        .type-psychic { background-color: #F85888; }
        .type-bug { background-color: #A8B820; }
        .type-rock { background-color: #B8A038; }
        .type-ghost { background-color: #705898; }
        .type-dragon { background-color: #7038F8; }
        .type-dark { background-color: #705848; }
        .type-steel { background-color: #B8B8D0; }
        .type-fairy { background-color: #F0B6BC; }
        /* Animation for canvas */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        .pokemon-image canvas:hover {
            animation: pulse 1s infinite;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Pokémon Information</h1>
        <div class="search-container">
            <input type="text" id="search-bar" placeholder="Search Pokémon (e.g., Mew)" autocomplete="off">
            <div id="suggestions"></div>
        </div>
        <div id="pokemon-info" class="pokemon-info">
            <div class="pokemon-image">
                <canvas id="pokemon-canvas" width="200" height="200"></canvas>
            </div>
            <div class="details">
                <p><strong>Name:</strong> <span id="name"></span></p>
                <p><strong>ID:</strong> <span id="id"></span></p>
                <p><strong>Types:</strong> <span id="types"></span></p>
                <p><strong>Height:</strong> <span id="height"></span></p>
                <p><strong>Weight:</strong> <span id="weight"></span></p>
                <p><strong>Abilities:</strong> <span id="abilities"></span></p>
                <p><strong>Weaknesses:</strong> <span id="weaknesses"></span></p>
                <p><strong>Evolutions:</strong> <span id="evolutions"></span></p>
                <p><strong>Moves:</strong></p>
                <ul id="moves" class="moves-list"></ul>
            </div>
        </div>
        <p id="error" class="error" style="display: none;"></p>
    </div>

    <script>
        const typeChart = {
            normal: ["fighting"],
            fire: ["water", "rock", "electric"],
            water: ["grass", "electric"],
            grass: ["fire", "poison", "flying", "bug", "ice"],
            electric: ["ground"],
            ice: ["fire", "fighting", "rock", "steel"],
            fighting: ["flying", "psychic", "fairy"],
            poison: ["ground", "psychic"],
            ground: ["water", "grass", "ice"],
            flying: ["electric", "ice", "rock"],
            psychic: ["bug", "ghost", "dark"],
            bug: ["fire", "flying", "rock"],
            rock: ["water", "grass", "fighting", "ground", "steel"],
            ghost: ["ghost", "dark"],
            dragon: ["ice", "dragon", "fairy"],
            dark: ["fighting", "bug", "fairy"],
            steel: ["fire", "fighting", "ground"],
            fairy: ["poison", "steel"]
        };

        let allPokemonNames = [];

        // Fetch all Pokémon names for suggestions
        async function fetchAllPokemonNames() {
            try {
                const response = await fetch('https://pokeapi.co/api/v2/pokemon?limit=10000');
                if (!response.ok) throw new Error('Failed to fetch Pokémon list');
                const data = await response.json();
                allPokemonNames = data.results.map(p => p.name);
            } catch (error) {
                console.error('Error fetching Pokémon names:', error);
                document.getElementById('error').textContent = 'Failed to load Pokémon list';
                document.getElementById('error').style.display = 'block';
            }
        }

        // Fetch Pokémon info
        async function fetchPokemonInfo(pokemonName) {
            try {
                const response = await fetch(`https://pokeapi.co/api/v2/pokemon/${pokemonName.toLowerCase()}`);
                if (!response.ok) throw new Error(`Pokémon '${pokemonName}' not found`);
                const data = await response.json();
                const types = data.types.map(t => t.type.name);

                // Fetch evolution chain
                const speciesResponse = await fetch(data.species.url);
                if (!speciesResponse.ok) throw new Error('Failed to fetch species data');
                const speciesData = await speciesResponse.json();
                const evolutionResponse = await fetch(speciesData.evolution_chain.url);
                if (!evolutionResponse.ok) throw new Error('Failed to fetch evolution chain');
                const evolutionData = await evolutionResponse.json();
                const evolutions = getEvolutionChain(evolutionData.chain);

                // Fetch move details (power and accuracy)
                const moves = await Promise.all(
                    data.moves.map(async m => {
                        const moveResponse = await fetch(m.move.url);
                        if (!moveResponse.ok) return { name: m.move.name, power: 'N/A', accuracy: 'N/A' };
                        const moveData = await moveResponse.json();
                        return {
                            name: m.move.name,
                            power: moveData.power ?? 'N/A',
                            accuracy: moveData.accuracy ?? 'N/A'
                        };
                    })
                );

                return {
                    name: data.name.charAt(0).toUpperCase() + data.name.slice(1),
                    id: data.id,
                    types: types,
                    height: data.height,
                    weight: data.weight,
                    abilities: data.abilities.map(a => a.ability.name),
                    image: data.sprites.front_default,
                    weaknesses: getWeaknesses(types),
                    evolutions: evolutions,
                    moves: moves
                };
            } catch (error) {
                document.getElementById('error').textContent = error.message;
                document.getElementById('error').style.display = 'block';
                return null;
            }
        }

        function getWeaknesses(types) {
            let weaknesses = [];
            types.forEach(type => {
                if (typeChart[type]) {
                    weaknesses = [...weaknesses, ...typeChart[type]];
                }
            });
            return [...new Set(weaknesses)];
        }

        function getEvolutionChain(chain) {
            const evolutions = [];
            let current = chain;
            while (current) {
                evolutions.push(current.species.name.charAt(0).toUpperCase() + current.species.name.slice(1));
                current = current.evolves_to[0]; // Take first evolution (simplified)
            }
            return evolutions;
        }

        function drawPokemonSprite(canvas, imageUrl) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw gradient background
            const gradient = ctx.createRadialGradient(100, 100, 20, 100, 100, 100);
            gradient.addColorStop(0, '#ffffff');
            gradient.addColorStop(1, '#f0f0f0');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw Pokémon sprite
            const img = new Image();
            img.crossOrigin = "Anonymous";
            img.onload = () => {
                ctx.drawImage(img, 50, 50, 100, 100);
            };
            img.onerror = () => {
                console.error('Failed to load sprite:', imageUrl);
                document.getElementById('error').textContent = 'Failed to load Pokémon sprite';
                document.getElementById('error').style.display = 'block';
            };
            img.src = imageUrl;
        }

        async function displayPokemonInfo(pokemonName) {
            const pokemon = await fetchPokemonInfo(pokemonName);
            if (!pokemon) return;

            // Update DOM
            document.getElementById('name').textContent = pokemon.name;
            document.getElementById('id').textContent = pokemon.id;
            document.getElementById('types').textContent = pokemon.types.join(', ');
            document.getElementById('height').textContent = `${pokemon.height / 10} m`;
            document.getElementById('weight').textContent = `${pokemon.weight / 10} kg`;
            document.getElementById('abilities').textContent = pokemon.abilities.join(', ');
            document.getElementById('weaknesses').textContent = pokemon.weaknesses.join(', ');
            document.getElementById('evolutions').textContent = pokemon.evolutions.join(' → ');

            const movesList = document.getElementById('moves');
            movesList.innerHTML = '';
            pokemon.moves.forEach(move => {
                const li = document.createElement('li');
                li.textContent = `${move.name} (Power: ${move.power}, Accuracy: ${move.accuracy}%)`;
                movesList.appendChild(li);
            });

            // Draw sprite on canvas
            const canvas = document.getElementById('pokemon-canvas');
            drawPokemonSprite(canvas, pokemon.image);

            // Set dynamic background
            document.body.className = `type-${pokemon.types[0]}`;

            // Update URL
            history.pushState({}, '', `?poke=${pokemonName.toLowerCase()}`);
        }

        // Handle search bar and suggestions
        const searchBar = document.getElementById('search-bar');
        const suggestionsDiv = document.getElementById('suggestions');

        searchBar.addEventListener('input', () => {
            const query = searchBar.value.toLowerCase();
            suggestionsDiv.innerHTML = '';
            if (query.length < 1) {
                suggestionsDiv.style.display = 'none';
                return;
            }

            const matches = allPokemonNames.filter(name => name.toLowerCase().includes(query)).slice(0, 10);
            matches.forEach(name => {
                const div = document.createElement('div');
                div.className = 'suggestion-item';
                div.textContent = name.charAt(0).toUpperCase() + name.slice(1);
                div.addEventListener('click', () => {
                    searchBar.value = div.textContent;
                    suggestionsDiv.style.display = 'none';
                    displayPokemonInfo(name);
                });
                suggestionsDiv.appendChild(div);
            });
            suggestionsDiv.style.display = matches.length > 0 ? 'block' : 'none';
        });

        // Hide suggestions when clicking outside
        document.addEventListener('click', (e) => {
            if (!searchBar.contains(e.target) && !suggestionsDiv.contains(e.target)) {
                suggestionsDiv.style.display = 'none';
            }
        });

        // Handle Enter key to search
        searchBar.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && searchBar.value) {
                suggestionsDiv.style.display = 'none';
                displayPokemonInfo(searchBar.value);
            }
        });

        // Initialize
        async function init() {
            await fetchAllPokemonNames();
            const urlParams = new URLSearchParams(window.location.search);
            const pokemonName = urlParams.get('poke') || 'pikachu';
            searchBar.value = pokemonName.charAt(0).toUpperCase() + pokemonName.slice(1);
            displayPokemonInfo(pokemonName);
        }

        init();
    </script>
</body>
</html>
